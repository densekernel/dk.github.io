<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>densekernel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            min-height: 100vh;
            background: #0a0a0a;
            color: #fafafa;
        }

        canvas {
            display: block;
            width: 100%;
            height: 50vh;
        }

        main {
            text-align: center;
            max-width: 480px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        h1 {
            font-weight: 300;
            font-size: 2rem;
            letter-spacing: 0.1em;
        }

        p {
            margin-top: 1.5rem;
            font-size: 0.95rem;
            line-height: 1.6;
            color: #888;
        }
    </style>
</head>
<body>
    <canvas id="kde"></canvas>
    <main>
        <h1>densekernel</h1>
        <p>A concentration of core knowledge. From kernel density estimation in statistics, to the kernel at the heart of an operating system, to the dense kernel of a seed. The essential part, tightly packed.</p>
    </main>
    <script>
        const canvas = document.getElementById('kde');
        const ctx = canvas.getContext('2d');

        let width, height;
        const peaks = [];
        const contourLevels = 18;
        const resolution = 2;
        let time = 0;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            width = canvas.offsetWidth;
            height = canvas.offsetHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }

        function gaussian(x, y, cx, cy, sigma, amplitude) {
            const dx = x - cx;
            const dy = y - cy;
            return amplitude * Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
        }

        function initPeaks() {
            peaks.length = 0;
            const spacing = 35;
            const jitter = 12;
            const cols = Math.ceil(width / spacing) + 2;
            const rows = Math.ceil(height / spacing) + 2;

            for (let row = -1; row <= rows; row++) {
                for (let col = -1; col <= cols; col++) {
                    peaks.push({
                        x: col * spacing + (Math.random() - 0.5) * jitter * 2,
                        y: row * spacing + (Math.random() - 0.5) * jitter * 2,
                        sigma: 15 + Math.random() * 20,
                        amplitude: 0.6 + Math.random() * 0.4,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.08 + Math.random() * 0.14
                    });
                }
            }
        }

        function getDensity(x, y) {
            let d = 0;
            for (const p of peaks) {
                const pulse = 0.8 + 0.2 * Math.sin(time * p.speed + p.phase);
                d += gaussian(x, y, p.x, p.y, p.sigma, p.amplitude * pulse);
            }
            return d;
        }

        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const cols = Math.ceil(width / resolution);
            const rows = Math.ceil(height / resolution);

            // Build density grid
            const grid = [];
            let maxD = 0;
            for (let j = 0; j <= rows; j++) {
                const row = [];
                for (let i = 0; i <= cols; i++) {
                    const d = getDensity(i * resolution, j * resolution);
                    if (d > maxD) maxD = d;
                    row.push(d);
                }
                grid.push(row);
            }

            // Draw contour lines using marching squares
            for (let level = 1; level <= contourLevels; level++) {
                const threshold = (level / (contourLevels + 1)) * maxD;
                const alpha = 0.1 + (level / contourLevels) * 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = level === contourLevels ? 1.5 : 1;

                ctx.beginPath();

                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const x = i * resolution;
                        const y = j * resolution;

                        const tl = grid[j][i] >= threshold ? 1 : 0;
                        const tr = grid[j][i + 1] >= threshold ? 1 : 0;
                        const br = grid[j + 1][i + 1] >= threshold ? 1 : 0;
                        const bl = grid[j + 1][i] >= threshold ? 1 : 0;

                        const config = tl * 8 + tr * 4 + br * 2 + bl;

                        const lerp = (va, vb) => {
                            if (Math.abs(vb - va) < 0.0001) return 0.5;
                            return (threshold - va) / (vb - va);
                        };

                        const top = { x: x + lerp(grid[j][i], grid[j][i + 1]) * resolution, y };
                        const right = { x: x + resolution, y: y + lerp(grid[j][i + 1], grid[j + 1][i + 1]) * resolution };
                        const bottom = { x: x + lerp(grid[j + 1][i], grid[j + 1][i + 1]) * resolution, y: y + resolution };
                        const left = { x, y: y + lerp(grid[j][i], grid[j + 1][i]) * resolution };

                        const drawLine = (p1, p2) => {
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        };

                        switch (config) {
                            case 1: case 14: drawLine(left, bottom); break;
                            case 2: case 13: drawLine(bottom, right); break;
                            case 3: case 12: drawLine(left, right); break;
                            case 4: case 11: drawLine(top, right); break;
                            case 5:
                                drawLine(left, top);
                                drawLine(bottom, right);
                                break;
                            case 6: case 9: drawLine(top, bottom); break;
                            case 7: case 8: drawLine(left, top); break;
                            case 10:
                                drawLine(top, right);
                                drawLine(left, bottom);
                                break;
                        }
                    }
                }
                ctx.stroke();
            }

            // Draw grid overlay
            const gridSpacing = 40;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= width; x += gridSpacing) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }
            for (let y = 0; y <= height; y += gridSpacing) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();

            time += 0.012;
            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', () => {
            resize();
            initPeaks();
        });

        resize();
        initPeaks();
        draw();
    </script>
</body>
</html>
